---
title: Controller Arguments
layout: default
---

A controller method which takes no arguments, for instance
`controller.Main.index()`, is accessed via a simple URL - in this case,
"`http://localhost:8080/Main/index`". If a controller method takes one or more
arguments, however, it will accept URL parameters corresponding to those
arguments, either as part of the URL itself (e.g.
"`http://localhost:8080/Post/view?id=5`") or in the body of the request (as
with a request generated by submitting an HTML form). The method will be
called with the values provided by the request. If a parameter is not included
in the request, `null` will be passed in (or `false` for boolean parameters).

## Simple parameters

If the method parameter's type is:

  * boolean
  * int/long/float/double
  * String
  * java.util.Date

or any other type to which Gosu can coerce a String, it will be set directly
using the value in the request. So given the following controller method
signature:

{% highlight js %}
    controller.Main.index(b : boolean, i : int, s : String, d : Date)
{% endhighlight %}

the following URL:

`http://localhost:8080/Main/index?b=true&i=5&s=Hello&d=07-11-1980`

will call

{% highlight js %}
    controller.Main.index(true, 5, "Hello", new java.util.Date("07-11-1980")).
{% endhighlight %}

If a parameter is of some other type, Ronin will attempt to find a static
method on that type called `fromId` which takes a single parameter and returns
an instance of the desired type. (In this documentation we will refer to such
types as **entity** types, though they can be any Gosu type.) If it finds such
a method, it will call it, passing in the value from the request, and assign
the result to the controller method's parameter.

For instance, given the following class:

{% highlight js %}
    class Person {
      static function fromId(id : long) : Person {
        return fetchPersonFromDb(id)
      }
    ...
    }
{% endhighlight %}

and the following controller method on `controller.Main`:

{% highlight js %}
    function viewPerson(p : Person) {
      ...
    }
{% endhighlight %}

the URL

`http://localhost:8080/Main/viewPerson?id=5`

will call

{% highlight js %}
    controller.Main.viewPerson(Person.fromId(5))
{% endhighlight %}

Don't forget that you can use a Gosu enhancement to add `fromId()` to an
existing type, such as a Hibernate class, thus turning it into a valid Ronin
entity type. You could even enhance a single interface implemented by all of
your entity types, though be careful to ensure that `fromId()` always returns
the concrete type, not the interface type (most likely through the use of a
type parameter on the enhancement). Consult the Gosu documentation for further
details on enhancements.

You can override this behavior by setting the `ParamConverter` property in the
constructor of your `RoninConfig` object.

## Complex parameters

Parameters of a non-primitive type and array parameters support a more
advanced syntax. Individual properties of a non-primitive parameter can be set
from URL parameters using a dot-path syntax. For instance, given the following
method signature:

{% highlight js %}
    function updatePerson(p : Person)
{% endhighlight %}

where Person is a Gosu class defining the following property:

{% highlight js %}
    var _name : String as Name
{% endhighlight %}

the URL "`http://localhost:8080/Main/updatePerson?p=0&p.Name=Bob`" will call
`Person.fromId(0)`, then set the `Name` property on that instance of `Person`
to "Bob".

If a property is specified in the URL, but no ID is given for the instance -
e.g. "`http://localhost:8080/Main/updatePerson?p.Name=Bob`" - a new `Person`
will be instantiated, and its `Name` set to "Bob". (This assumes that `Person`
defines a constructor with no arguments.)

For array parameters, an array is created automatically. Elements in the array
are specified in the URL using standard array notation, e.g.
"`names[0]=Bob&names[1]=Fred`". If the parameter is an array of entity types,
each value specified in this way is passed to `fromId()` to retrieve the
appropriate element.

Complex parameters make it very easy to create an HTML form for creating or
updating an entity. The controller method to which the form points need only
take a single parameter, the entity, and the name of each input in the form is
a dot path for the property it edits (e.g. "`p.Name`", or "`p.PhoneNumber`").

## Restricting properties

Setting properties on a parameter via request parameters could conceivably pose a
security risk.  For instance, say you have a page where a user can edit their profile.
This page posts to the following controller method:

{% highlight js %}
    function saveUser(u : User) {
      [code to save User object to database]
    }
{% endhighlight %}

An attacker could trick a user into posting to this method with the parameter
`u.Password` set to some value known to the attacker.

For this reason, Ronin allows you to specify that certain properties should **never** be
set automatically from request parameters.  There are two ways to do this.  If the property
in question is on a Gosu class, you can use the `@Restricted` annotation:

{% highlight js %}
    @Restricted
    var _password : String as Password
{% endhighlight %}

On the other hand, if the property is on another kind of type, or if you don't have control
over the class where it's defined (e.g. it's part of a third-party library), you can set the
`RestrictedProperties` from the constructor of your `RoninConfig` class:

{% highlight js %}
    RestrictedProperties = {(User#Password).PropertyInfo}
{% endhighlight %}

If you are setting a large number of restricted properties in this way, you may find it
convenient to do the following:

{% highlight js %}
    RestrictedProperties = {User#Password, User#Salt, ...}
      .map(\pr -> pr.PropertyInfo).toSet()
{% endhighlight %}

## Alternatives

In addition to passing parameters to a method as part of the URL, you can also
pass them as form-encoded data in the body of the HTTP request. This is what
will happen when you submit an HTML form, for example.

You can also pass in parameters via JSON in the body of the request. This
could be useful if, for instance, your application supports clients other than
a web browser, or you're using a Javascript UI framework which uses JSON for
AJAX requests. For more information, see [Using JSON for parameters](Using-JSON.html).

Next we'll see how [views](Views.html) work.
